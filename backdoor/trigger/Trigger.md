# Trigger

## 依赖于使用来自**不同分布**的触发器数据集

- 模型实际上是为两个不同(并且独立)的任务训练的
- 研究表明，当这些任务或多或少不相关时，可以**去除水印**，而不会影响模型对通过训练数据学习的原始任务的准确性

### 需要注意的问题

- **阈值**
  - 在基于触发数据集的水印方法中，水印检测依赖于模型对来自触发数据集的查询的反应
    - 如果对它们的预测与触发数据集的原始标签的一致性超过给定的阈值，则表明存在水印
  - 定义一个合适的阈值来识别被盗的模型需要进行彻底的调优
    - 表达了可靠性和完整性之间的权衡
- **公开验证**(?)
  - 在针对被盗模型运行验证算法后，攻击者拥有触发数据集，这使他们能够在这些数据点上微调模型以去除水印
- **鲁棒性**
  - 水印方案需要采取措施在两个任务之间建立关系，使其**不易被删除**
- **可靠性**
  - 如果水印方案没有提供一个可验证的链接，将水印和合法的模型所有者联系起来，那么攻击者就可能**伪造水印**
    - 依赖于非特定数据点作为触发数据的水印方案中（例如，Adi, 2018; Guo and Potkonjak, 2018）
      - 这些方案可能使得攻击者可以选择（随机）不同于初始水印的点，来声称他们用这些点作为触发器来标记模型
  - 水印模型对触发数据集预测的**唯一性**
    - 非水印模型如何对给定的触发数据集做出反应
- **容量**
  - 水印承载的信息量
- **效率**
  - 触发数据集的数据样本数量应该是原始数据的一半以上
    - 特别是对于大型数据集，这可能会导致很大的开销
- **通用性**
  - 是否可以泛化到其他数据集上
- **最优问题**
  - 触发集的选择与潜在窃取者的行为之间存在的关系

- **watermarking overwriting**
  - 第三方用户可以嵌入不同的水印以覆盖原始水印，造成现有水印的误码
  - 抗覆盖能力

## 方案

- Eidetic memory：使得LLM根据以前的**交互信息**来**召唤相关的记忆**(准确、特有)
- trigger：根据预设的规则，使模型学会**对来自触发数据集的数据点**表现出**不寻常的预测行为**



- 如何选择合适的Eidetic Memory**结构和存储方式**
- 如何选择合适的trigger**更新算法**
- 根据一定的规则或概率，**生成**嵌入水印后的文本

### 方案的优势

- 个性化和定制化能力：Eidetic memory的选择
  - 嵌入用户的特定标识或信息
- 安全性和可信度：长期保存相关的信息(Eidetic memory的特点)
  - 保证水印的有效
- 创造性和多样性：LLM本身的创造性不受影响

